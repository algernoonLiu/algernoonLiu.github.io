<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿尔杰农青年</title>
  <subtitle>爱生活爱编码</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://algernoonliu.github.io/"/>
  <updated>2017-07-04T10:50:06.482Z</updated>
  <id>https://algernoonliu.github.io/</id>
  
  <author>
    <name>algernoon青年</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ThreadLocal解决SimpleDateFormat线程安全问题</title>
    <link href="https://algernoonliu.github.io/2017/07/04/ThreadLocal%E8%A7%A3%E5%86%B3SimpleDateFormat%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://algernoonliu.github.io/2017/07/04/ThreadLocal解决SimpleDateFormat线程安全问题/</id>
    <published>2017-07-04T10:49:25.000Z</published>
    <updated>2017-07-04T10:50:06.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>SimpleDateFormat(下面简称sdf)类内部有一个Calendar对象引用，它用来储存和这个sdf相关的日期信息，例如<code>sdf.parse(dateStr)</code>， <code>sdf.format(date)</code>诸如此类的方法参数传入的日期相关String，Date等等，都是交友Calendar引用来储存的。这样就会导致一个问题，如果你的sdf是个static的，那么多个thread 之间就会共享这个sdf，同时也是共享这个Calendar引用，并且，观察<code>sdf.parse()</code>方法，你会发现有如下的调用：</p>
<pre><code>Date parse() {
  calendar.clear(); // 清理calendar
  ... // 执行一些操作, 设置 calendar 的日期什么的
  calendar.getTime(); // 获取calendar的时间
}
</code></pre><p>这里会导致的问题就是，如果线程A调用了<code>sdf.parse()</code>，并且进行了<code>calendar.clear()</code>后还未执行<code>calendar.getTime()</code>的时候，线程B又调用了<code>sdf.parse()</code>，这时候线程B也执行了<code>sdf.clear()</code>方法，这样就导致线程 A 的的calendar数据被清空了(实际上A，B的同时被清空了)。又或者当 A 执行了<code>calendar.clear()</code>后被挂起，这时候 B 开始调用<code>sdf.parse()</code>并顺利结束，这样 A 的 calendar内存储的的date 变成了后来 B 设置的calendar的date。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>最简单的解决方案我们可以把static去掉，这样每个新的线程都会有一个自己的sdf实例，从而避免线程安全的问题。然而，使用这种方法，在高并发的情况下会大量的<code>new sdf</code>以及销毁sdf，这样是非常耗费资源的，所以是不可行的。</p>
<p>另外一种方法可以使用Threadlocal解决此问题，对于每个线程SimpleDateFormat不存在影响他们之间协作的状态，为每个线程创建一个SimpleDateFormat变量的拷贝或者叫做副本，代码如下：</p>
<pre><code>/** 
 * 使用ThreadLocal以空间换时间解决SimpleDateFormat线程安全问题。 
 */  
public class DateUtil {  

    private static final String DATE_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;;  

    @SuppressWarnings(&quot;rawtypes&quot;)  
    private static ThreadLocal threadLocal = new ThreadLocal() {  
        protected synchronized Object initialValue() {  
            return new SimpleDateFormat(DATE_FORMAT);  
        }  
    };  

    public static DateFormat getDateFormat() {  
        return (DateFormat) threadLocal.get();  
    }  

    public static Date parse(String textDate) throws ParseException {  
        return getDateFormat().parse(textDate);  
    }  
}
</code></pre><p> 创建一个ThreadLocal类变量，这里创建时用了一个匿名类，覆盖了initialValue方法，主要作用是创建时初始化实例，也可以采用下面方式创建。</p>
<pre><code>//第一次调用get将返回null  
private static ThreadLocal threadLocal = new ThreadLocal()；  
//获取线程的变量副本，如果不覆盖initialValue，第一次get返回null，故需要初始化一个SimpleDateFormat，并set到threadLocal中  
public static DateFormat getDateFormat() {  
    DateFormat df = (DateFormat) threadLocal.get();  
    if(df==null){
        df = new SimpleDateFormat(DATE_FORMAT)  
        threadLocal.set(df);  
    }  
    return df;  
}
</code></pre><p>通过以上方式，每个线程会实例化一个SimpleDateFormat实例，实例在线程内共享，达到了解决线程安全性的问题，一定程度上也提高了性能。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原因分析&quot;&gt;&lt;a href=&quot;#原因分析&quot; class=&quot;headerlink&quot; title=&quot;原因分析&quot;&gt;&lt;/a&gt;原因分析&lt;/h3&gt;&lt;p&gt;SimpleDateFormat(下面简称sdf)类内部有一个Calendar对象引用，它用来储存和这个sdf相关的日期信息
    
    </summary>
    
      <category term="java基础" scheme="https://algernoonliu.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://algernoonliu.github.io/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="ThreadLocal" scheme="https://algernoonliu.github.io/tags/ThreadLocal/"/>
    
      <category term="多线程" scheme="https://algernoonliu.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal深入理解</title>
    <link href="https://algernoonliu.github.io/2017/06/30/ThreadLocal%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>https://algernoonliu.github.io/2017/06/30/ThreadLocal深入理解/</id>
    <published>2017-06-30T08:38:49.000Z</published>
    <updated>2017-06-30T09:00:06.005Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal概述"><a href="#ThreadLocal概述" class="headerlink" title="ThreadLocal概述"></a>ThreadLocal概述</h3><p>学习一个东西首先要知道为什么要引入它，就是我们能用它来干什么。所以我们先来看看ThreadLocal对我们到底有什么用，然后再来看看它的实现原理。</p>
<p>ThreadLocal如果单纯从名字上来看像是“本地线程”这么个意思，只能说这个名字起的确实不太好，很容易让人产生误解，ThreadLocalVariable（线程本地变量）应该是个更好的名字。我们先看一下官方对ThreadLocal的描述：</p>
<pre><code>This class provides thread-local variables.  These variables differ from their normal counterparts in that each
thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized
copy of the variable.  {@code ThreadLocal} instances are typically private static fields in classes that wish
to associate state with a thread (e.g., a user ID or Transaction ID).
</code></pre><p> API表达了下面几种观点：</p>
<p>   1、ThreadLocal不是线程，是用来提供线程内部的局部变量，你可以先简单理解为线程类的属性变量。</p>
<p>   2、多线程环境中每个线程有自己的ThreadLocal的变量‘拷贝’，（通过get或set方法访问）时能保证各个线程里的变量线程相对独立于其他线程内的变量，修改本线程局部变量不影响其他线程中的局部变量。</p>
<p>   3、ThreadLocal实例通常来说都是private static类型。 </p>
<p><strong>小结：</strong></p>
<p>1、每个线程都有自己的局部变量</p>
<p>   &emsp;&nbsp;&nbsp;每个线程都有一个独立于其他线程的上下文来保存这个变量，一个线程的本地变量对其他线程是不可见的（有前提，后面解释）</p>
<p>2、独立于变量的初始化副本</p>
<p>   &emsp;&nbsp;&nbsp;ThreadLocal可以给一个初始值，而每个线程都会获得这个初始化值的一个副本，这样才能保证不同的线程都有一份拷贝。</p>
<p>3、状态与某一个线程相关联</p>
<p>   &emsp;&nbsp;&nbsp;ThreadLocal 不是用于解决共享变量的问题的，不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制，理解这点对正确使用ThreadLocal至关重要。</p>
<blockquote>
<p>ThreadLocal适用于资源共享但不需要维护状态的情况，也就是一个线程对资源的修改，不影响另一个线程的运行；这种设计是“空间换时间”，synchronized顺序执行是“时间换取空间”。</p>
<p>ThreadLocal的主要应用场景为按线程多实例（每个线程对应一个实例）的对象的访问，并且这个对象很多地方都要用到。例如：同一个网站登录用户，每个用户服务器会为其开一个线程，每个线程中创建一个ThreadLocal，里面存用户基本信息等，在很多页面跳转时，会显示用户信息或者得到用户的一些信息等频繁操作，这样多线程之间并没有联系而且当前线程也可以及时获取想要的数据。</p>
</blockquote>
<h3 id="ThreadLocal实现原理"><a href="#ThreadLocal实现原理" class="headerlink" title="ThreadLocal实现原理"></a>ThreadLocal实现原理</h3><p>ThreadLocal可以看做是一个容器，容器里面存放着属于当前线程的变量。ThreadLocal类提供了四个对外开放的接口方法，这也是用户操作ThreadLocal类的基本方法： </p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">T</td>
<td style="text-align:left">get()&emsp;返回此线程局部变量的当前线程副本中的值。</td>
</tr>
<tr>
<td style="text-align:left">protected T</td>
<td style="text-align:left">initialValue()&emsp;返回此线程局部变量的当前线程的“初始值”。</td>
</tr>
<tr>
<td style="text-align:left">void</td>
<td style="text-align:left">remove()&emsp;移除此线程局部变量当前线程的值。</td>
</tr>
<tr>
<td style="text-align:left">void</td>
<td style="text-align:left">set(T value)&emsp;将此线程局部变量的当前线程副本中的值设置为指定值。</td>
</tr>
</tbody>
</table>
<p>可以通过上述的几个方法实现ThreadLocal中变量的访问，数据设置，初始化以及删除局部变量，那ThreadLocal内部是如何为每一个线程维护变量副本的呢？</p>
<p>其实在ThreadLocal类中有一个静态内部类ThreadLocalMap(其类似于Map)，用键值对的形式存储每一个线程的变量副本，ThreadLocalMap中元素的key为当前ThreadLocal对象，而value对应线程的变量副本，每个线程可能存在多个ThreadLocal。</p>
<p>ThreadLocal类源代码：</p>
<pre><code>/**
 * Returns the value in the current thread&apos;s copy of this
 * thread-local variable.  If the variable has no value for thecurrent thread, it is first initialized to the
 * value returned by an invocation of the {@link #initialValue} method.
 * @return the current thread&apos;s value of this thread-local
 */
public T get() {
    Thread t = Thread.currentThread();//当前线程
    ThreadLocalMap map = getMap(t);//获取当前线程对应的ThreadLocalMap
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);//获取对应ThreadLocal的变量值
        if (e != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();//若当前线程还未创建ThreadLocalMap，则返回调用此方法并在其中调用createMap方法进行创建并返回初始值。
}

//设置变量的值
public void set(T value) {
   Thread t = Thread.currentThread();
   ThreadLocalMap map = getMap(t);
   if (map != null)
       map.set(this, value);
   else
       createMap(t, value);
}

private T setInitialValue() {
   T value = initialValue();
   Thread t = Thread.currentThread();
   ThreadLocalMap map = getMap(t);
   if (map != null)
       map.set(this, value);
   else
       createMap(t, value);
   return value;
}

/**
 * 为当前线程创建一个ThreadLocalMap的threadlocals,并将第一个值存入到当前map中
 * @param t the current thread
 * @param firstValue value for the initial entry of the map
 */
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}

//删除当前线程中ThreadLocalMap对应的ThreadLocal
public void remove() {
       ThreadLocalMap m = getMap(Thread.currentThread());
       if (m != null)
           m.remove(this);
}
</code></pre><p>上述是在ThreadLocal类中的几个主要的方法，他们的核心都是对其内部类ThreadLocalMap进行操作，下面看一下该类的源代码：</p>
<pre><code>static class ThreadLocalMap {
    //map中的每个节点Entry,其键key是ThreadLocal并且还是弱引用，这也导致了后续会产生内存泄漏问题的原因。
     static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
        /** The value associated with this ThreadLocal. */
        Object value;

        Entry(ThreadLocal&lt;?&gt; k, Object v) {
            super(k);
            value = v;
        }
    }
    /**
     * 初始化容量为16，以为对其扩充也必须是2的指数 
     */
    private static final int INITIAL_CAPACITY = 16;
    /**
     * 真正用于存储线程的每个ThreadLocal的数组，将ThreadLocal和其对应的值包装为一个Entry。
     */
    private Entry[] table;


    ///....其他的方法和操作都和map的类似
}
</code></pre><p>总之，为不同线程创建不同的ThreadLocalMap，用线程本身为区分点，每个线程之间其实没有任何的联系，说是说存放了变量的副本，其实可以理解为为每个线程单独new了一个对象。</p>
<h3 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h3><p>在上面提到过，每个thread中都存在一个map，map的类型是ThreadLocal.ThreadLocalMap。Map中的key为一个threadlocal实例。这个Map的确使用了弱引用，不过弱引用只是针对key。每个key都弱引用指向threadlocal。当把threadlocal实例置为null以后，没有任何强引用指向threadlocal实例，所以threadlocal将会被gc回收。但是，我们的value却不能回收，因为存在一条从current thread连接过来的强引用。只有当前thread结束以后，current thread就不会存在栈中，强引用断开，Current Thread，Map，value将全部被GC回收。</p>
<p>所以得出一个结论就是只要这个线程对象被gc回收，就不会出现内存泄露，但在threadLocal设为null和线程结束这段时间不会被回收的，就发生了我们认为的内存泄露。其实这是一个对概念理解的不一致，也没什么好争论的。最要命的是线程对象不被回收的情况，这就发生了真正意义上的内存泄露。比如使用线程池的时候，线程结束是不会销毁的，会再次使用的。就可能出现内存泄露。</p>
<p>虽然ThreadLocalMap已经使用了weakReference，但是还是建议能够显示的使用remove方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ThreadLocal概述&quot;&gt;&lt;a href=&quot;#ThreadLocal概述&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal概述&quot;&gt;&lt;/a&gt;ThreadLocal概述&lt;/h3&gt;&lt;p&gt;学习一个东西首先要知道为什么要引入它，就是我们能用它
    
    </summary>
    
      <category term="java基础" scheme="https://algernoonliu.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://algernoonliu.github.io/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="ThreadLocal" scheme="https://algernoonliu.github.io/tags/ThreadLocal/"/>
    
      <category term="多线程" scheme="https://algernoonliu.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://algernoonliu.github.io/2017/06/22/hello-world/"/>
    <id>https://algernoonliu.github.io/2017/06/22/hello-world/</id>
    <published>2017-06-22T08:07:41.980Z</published>
    <updated>2017-06-22T08:07:41.980Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
